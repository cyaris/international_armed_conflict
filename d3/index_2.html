<!DOCTYPE html>
<meta charset="utf-8">
<style>

circle {
  stroke: #000;
  stroke-width: 2px;
}

line {
  stroke: #999;
  stroke-opacity: .6;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
}


</style>
<body>
<script src="//d3js.org/d3.v3.min.js"></script>
<script>

var width = 960,
    height = 500;

var fill = d3.scale.category20();

var radius = d3.scale.sqrt()
    .range([0, 6]);

var force = d3.layout.force()
    .size([width, height])
    .charge(-400)
    .linkDistance(function(d) { return radius(d.source.size) + radius(d.target.size) + 20; });

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

d3.json("network.json", function(error, graph) {
  if (error) throw error;
  var linkNodes = [];

  graph.links.forEach(function(link) {
    linkNodes.push({
      source: graph.nodes[link.source],
      target: graph.nodes[link.target]
    });
  });

  force
      .nodes(graph.nodes.concat(linkNodes))
      .links(graph.links)
      .on("tick", tick)
      .start();

  var link = svg.selectAll(".link")
    .data(graph.links)
  .enter().append("line")
    .attr("class", "link")
    .style("stroke-width", function(d) { return (d.bond * 2 - 1) * 3 + "px"; });

// link.filter(function(d) { return d.bond > 1; }).append("line")
    // .attr("class", "separator");

  var node = svg.selectAll("circle")
      .data(graph.nodes)
    .enter().append("circle")
      .attr("r", function(d) { return radius(d.size); })
      .style("fill", function(d) { return fill(d.country); })
      .call(force.drag);

  var nodelabels = svg.selectAll(".nodelabel")
     .data(graph.nodes)
     .enter().append("text")
       .attr("dy", ".35em")
       .attr("text-anchor", "middle")
       .text(function(d) { return d.country; });

   var linkNode = svg.selectAll(".link-node")
       .data(linkNodes)
     .enter().append("circle")
       .attr("class", "link-node")
       .attr("r", 0)
       .style("fill", "#ccc");

   function tick(e) {
     var q = d3.geom.quadtree(graph.nodes),
         i = 0,
         n = graph.nodes.length;
     while (++i < n) q.visit(collide(graph.nodes[i]));

       node.attr("cx", function(d) { return d.x = Math.max(radius(d.size) * 2, Math.min(width - radius(d.size) * 1.5, d.x)); })
           .attr("cy", function(d) { return d.y = Math.max(radius(d.size) * 2, Math.min(height - radius(d.size) * 1.5, d.y)); });

       nodelabels.attr("x", function(d) { return d.x = Math.max(radius(d.size) * 2, Math.min(width - radius(d.size) * 1.5, d.x)); })
                 .attr("y", function(d) { return d.y = Math.max(radius(d.size) * 2, Math.min(height - radius(d.size) * 1.5, d.y)); });

       link.attr("x1", function(d) { return d.source.x; })
           .attr("y1", function(d) { return d.source.y; })
           .attr("x2", function(d) { return d.target.x; })
           .attr("y2", function(d) { return d.target.y; });

       linkNode.attr("cx", function(d) { return d.x = (d.source.x + d.target.x) * 0.5; })
               .attr("cy", function(d) { return d.y = (d.source.y + d.target.y) * 0.5; });
   };
   svg.on("mousemove", function() {
     var p1 = d3.mouse(this);
     root.px = p1[0];
     root.py = p1[1];
     force.resume();
   });
   function collide(node) {
     var r = node.radius + 16,
         nx1 = node.x - r,
         nx2 = node.x + r,
         ny1 = node.y - r,
         ny2 = node.y + r;
     return function(quad, x1, y1, x2, y2) {
       if (quad.point && (quad.point !== node)) {
         var x = node.x - quad.point.x,
             y = node.y - quad.point.y,
             l = Math.sqrt(x * x + y * y),
             r = node.radius + quad.point.radius;
         if (l < r) {
           l = (l - r) / l * .5;
           node.x -= x *= l;
           node.y -= y *= l;
           quad.point.x += x;
           quad.point.y += y;
         }
       }
       return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
     };
   }
 });

</script>
